<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="An introductory resource for working with geographic data in Python">

<title>Geocomputation with Python - 3&nbsp; Spatial data operations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./05-geometry-operations.html" rel="next">
<link href="./03-attribute-operations.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./04-spatial-operations.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatial data operations</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Geocomputation with Python</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/geocompx/geocompy/" rel="" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-spatial-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Geographic data in Python</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-attribute-operations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Attribute data operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-spatial-operations.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatial data operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-geometry-operations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Geometry operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-raster-vector.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Raster-vector interactions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-reproj.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Reprojecting geographic data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-read-write-plot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Geographic data I/O</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-mapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Making maps with Python</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
  <h2 class="anchored">Note: The book is under construction üèó</h2>
  <ul>
    <li><a href="https://github.com/geocompr/py/issues" class="nav-link active" data-scroll-target="https\://github.com/geocompr/py/issues">Open an issue ‚ùî</a></li>
    <li><a href="https://discord.gg/PMztXYgNxp" class="nav-link" data-scroll-target="https\://discord.gg/PMztXYgNxp">Chat on Discord üì£</a></li>
  </ul>
  <hr>
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#prerequisites" id="toc-prerequisites" class="nav-link" data-scroll-target="#prerequisites"><span class="header-section-number">3.1</span> Prerequisites</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">3.2</span> Introduction</a></li>
  <li><a href="#sec-spatial-vec" id="toc-sec-spatial-vec" class="nav-link" data-scroll-target="#sec-spatial-vec"><span class="header-section-number">3.3</span> Spatial operations on vector data</a>
  <ul>
  <li><a href="#sec-spatial-subsetting" id="toc-sec-spatial-subsetting" class="nav-link" data-scroll-target="#sec-spatial-subsetting"><span class="header-section-number">3.3.1</span> Spatial subsetting</a></li>
  <li><a href="#sec-topological-relations" id="toc-sec-topological-relations" class="nav-link" data-scroll-target="#sec-topological-relations"><span class="header-section-number">3.3.2</span> Topological relations</a></li>
  <li><a href="#de-9im-strings" id="toc-de-9im-strings" class="nav-link" data-scroll-target="#de-9im-strings"><span class="header-section-number">3.3.3</span> DE-9IM strings</a></li>
  <li><a href="#sec-spatial-joining" id="toc-sec-spatial-joining" class="nav-link" data-scroll-target="#sec-spatial-joining"><span class="header-section-number">3.3.4</span> Spatial joining</a></li>
  <li><a href="#non-overlapping-joins" id="toc-non-overlapping-joins" class="nav-link" data-scroll-target="#non-overlapping-joins"><span class="header-section-number">3.3.5</span> Non-overlapping joins</a></li>
  <li><a href="#spatial-aggregation" id="toc-spatial-aggregation" class="nav-link" data-scroll-target="#spatial-aggregation"><span class="header-section-number">3.3.6</span> Spatial aggregation</a></li>
  <li><a href="#joining-incongruent-layers" id="toc-joining-incongruent-layers" class="nav-link" data-scroll-target="#joining-incongruent-layers"><span class="header-section-number">3.3.7</span> Joining incongruent layers</a></li>
  <li><a href="#distance-relations" id="toc-distance-relations" class="nav-link" data-scroll-target="#distance-relations"><span class="header-section-number">3.3.8</span> Distance relations</a></li>
  </ul></li>
  <li><a href="#sec-spatial-ras" id="toc-sec-spatial-ras" class="nav-link" data-scroll-target="#sec-spatial-ras"><span class="header-section-number">3.4</span> Spatial operations on raster data</a>
  <ul>
  <li><a href="#sec-spatial-subsetting" id="toc-sec-spatial-subsetting" class="nav-link" data-scroll-target="#sec-spatial-subsetting"><span class="header-section-number">3.4.1</span> Spatial subsetting</a></li>
  <li><a href="#sec-map-algebra" id="toc-sec-map-algebra" class="nav-link" data-scroll-target="#sec-map-algebra"><span class="header-section-number">3.4.2</span> Map algebra</a></li>
  <li><a href="#sec-raster-local-operations" id="toc-sec-raster-local-operations" class="nav-link" data-scroll-target="#sec-raster-local-operations"><span class="header-section-number">3.4.3</span> Local operations</a></li>
  <li><a href="#focal-operations" id="toc-focal-operations" class="nav-link" data-scroll-target="#focal-operations"><span class="header-section-number">3.4.4</span> Focal operations</a></li>
  <li><a href="#zonal-operations" id="toc-zonal-operations" class="nav-link" data-scroll-target="#zonal-operations"><span class="header-section-number">3.4.5</span> Zonal operations</a></li>
  <li><a href="#sec-global-operations-and-distances" id="toc-sec-global-operations-and-distances" class="nav-link" data-scroll-target="#sec-global-operations-and-distances"><span class="header-section-number">3.4.6</span> Global operations and distances</a></li>
  <li><a href="#map-algebra-counterparts-in-vector-processing" id="toc-map-algebra-counterparts-in-vector-processing" class="nav-link" data-scroll-target="#map-algebra-counterparts-in-vector-processing"><span class="header-section-number">3.4.7</span> Map algebra counterparts in vector processing</a></li>
  <li><a href="#merging-rasters" id="toc-merging-rasters" class="nav-link" data-scroll-target="#merging-rasters"><span class="header-section-number">3.4.8</span> Merging rasters</a></li>
  </ul></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">3.5</span> Exercises</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/geocompx/geocompy/edit/main/04-spatial-operations.qmd" class="toc-action">Edit this page</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-spatial-operations" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatial data operations</span></span></h1>
</div>

<!--
-->


<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="prerequisites" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="prerequisites"><span class="header-section-number">3.1</span> Prerequisites</h2>
<p>Let‚Äôs import the required packages:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shapely</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.ndimage</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio.plot</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio.merge</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio.features</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and load the sample data for this chapter:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>nz <span class="op">=</span> gpd.read_file(<span class="st">'data/nz.gpkg'</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>nz_height <span class="op">=</span> gpd.read_file(<span class="st">'data/nz_height.gpkg'</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>world <span class="op">=</span> gpd.read_file(<span class="st">'data/world.gpkg'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>cycle_hire <span class="op">=</span> gpd.read_file(<span class="st">'data/cycle_hire.gpkg'</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>cycle_hire_osm <span class="op">=</span> gpd.read_file(<span class="st">'data/cycle_hire_osm.gpkg'</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>src_elev <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'data/elev.tif'</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>src_multi_rast <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'data/landsat.tif'</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>src_grain <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'data/grain.tif'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="introduction" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="introduction"><span class="header-section-number">3.2</span> Introduction</h2>
</section>
<section id="sec-spatial-vec" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-spatial-vec"><span class="header-section-number">3.3</span> Spatial operations on vector data</h2>
<section id="sec-spatial-subsetting" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="sec-spatial-subsetting"><span class="header-section-number">3.3.1</span> Spatial subsetting</h3>
<p>Spatial subsetting is the process of taking a spatial object and returning a new object containing only features that relate in space to another object. Analogous to attribute subsetting (covered in <a href="#sec-vector-attribute-subsetting"><span class="quarto-unresolved-ref">sec-vector-attribute-subsetting</span></a>), subsets of <code>GeoDataFrame</code>s can be created with square bracket (<code>[</code>) operator using the syntax <code>x[y]</code>, where <code>x</code> is an <code>GeoDataFrame</code> from which a subset of rows/features will be returned, and <code>y</code> is the ‚Äòsubsetting object‚Äô. <code>y</code>, in turn, can be created using one of the binary geometry relation methods, such as <code>.intersects</code> (see <a href="#sec-topological-relations"><span class="quarto-unresolved-ref">sec-topological-relations</span></a>).</p>
<p>To demonstrate spatial subsetting, we will use the <code>nz</code> and <code>nz_height</code> layers, which contain geographic data on the 16 main regions and 101 highest points in New Zealand, respectively (<a href="#fig-spatial-subset">Figure&nbsp;<span class="quarto-unresolved-ref">fig-spatial-subset</span></a>), in a projected coordinate system. The following lines of code create an object representing Canterbury (<code>canterbury</code>), then use spatial subsetting to return all high points in the region (<code>canterbury_height</code>):</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>canterbury <span class="op">=</span> nz[nz[<span class="st">'Name'</span>] <span class="op">==</span> <span class="st">'Canterbury'</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>canterbury</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Island</th>
<th data-quarto-table-cell-role="th">Land_area</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">Median_income</th>
<th data-quarto-table-cell-role="th">Sex_ratio</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">10</td>
<td>Canterbury</td>
<td>South</td>
<td>44504.499091</td>
<td>...</td>
<td>30100</td>
<td>0.975327</td>
<td>MULTIPOLYGON (((1686901.914 535...</td>
</tr>
</tbody>
</table>

<p>1 rows √ó 7 columns</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Does each 'nz_height' point intersect with 'canterbury'?</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> nz_height.intersects(canterbury[<span class="st">'geometry'</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>sel</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>0      False
1      False
       ...  
99     False
100    False
Length: 101, dtype: bool</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>canterbury_height <span class="op">=</span> nz_height[sel]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>canterbury_height</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">t50_fid</th>
<th data-quarto-table-cell-role="th">elevation</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2362630</td>
<td>2749</td>
<td>POINT (1378169.600 5158491.453)</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>2362814</td>
<td>2822</td>
<td>POINT (1389460.041 5168749.086)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">93</td>
<td>2380300</td>
<td>2711</td>
<td>POINT (1654213.379 5349962.973)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">94</td>
<td>2380308</td>
<td>2885</td>
<td>POINT (1654898.622 5350462.779)</td>
</tr>
</tbody>
</table>

<p>70 rows √ó 3 columns</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> nz.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>nz_height.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> nz.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>canterbury.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'grey'</span>, edgecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>canterbury_height.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Subset (intersects)'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-spatial-subset" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-spatial-subset-output-1.png" width="579" height="374" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.1: Spatial subsetting of points by intersection with polygon</figcaption>
</figure>
</div>
</div>
</div>
<p>Like in attribute subsetting (<a href="#sec-vector-attribute-subsetting"><span class="quarto-unresolved-ref">sec-vector-attribute-subsetting</span></a>), we are using a boolean series (<code>sel</code>), of the same length as the number of rows in the filtered table (<code>nz_height</code>), created based on a condition applied on itself. The difference is that the condition is not a comparison of attribute values, but an evaluation of a spatial relation. Namely, we evaluate whether each geometry of <code>nz_height</code> intersects with <code>canterbury</code> geometry, using the <code>.intersects</code> method.</p>
<p>Various topological relations can be used for spatial subsetting which determine the type of spatial relationship that features in the target object must have with the subsetting object to be selected. These include touches, crosses or within, as we will see shortly in <a href="#sec-topological-relations"><span class="quarto-unresolved-ref">sec-topological-relations</span></a>. The most commonly used method <code>.intersects</code> method which we used in the last example is a ‚Äòcatch all‚Äô topological relation, that will return features in the target that touch, cross or are within the source ‚Äòsubsetting‚Äô object. Alternatively, we can evaluate other methods, such as <code>.disjoint</code> to obtain all points that <em>do not</em> intersect with Canterbury:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Is each 'nz_height' point disjoint from 'canterbury'?</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> nz_height.disjoint(canterbury[<span class="st">'geometry'</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>canterbury_height2 <span class="op">=</span> nz_height[sel]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>as shown in <a href="#fig-spatial-subset-disjoint">Figure&nbsp;<span class="quarto-unresolved-ref">fig-spatial-subset-disjoint</span></a>:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> nz.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>nz_height.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> nz.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>canterbury.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'grey'</span>, edgecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>canterbury_height2.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Subset (disjoint)'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-spatial-subset-disjoint" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-spatial-subset-disjoint-output-1.png" width="579" height="374" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.2: Spatial subsetting of points disjoint from a polygon</figcaption>
</figure>
</div>
</div>
</div>
<p>In case we need to subset according to several geometries at once, e.g., find out which points intersect with both Canterbury and Southland, we can dissolve the filtering subset before applying the <code>.intersects</code> (or any other) operator:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>canterbury_southland <span class="op">=</span> nz[(nz[<span class="st">'Name'</span>] <span class="op">==</span> <span class="st">'Canterbury'</span>) <span class="op">|</span> (nz[<span class="st">'Name'</span>] <span class="op">==</span> <span class="st">'Southland'</span>)]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>canterbury_southland <span class="op">=</span> canterbury_southland.unary_union</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>canterbury_southland</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<p><img src="04-spatial-operations_files/figure-html/cell-12-output-1.svg" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> nz_height.intersects(canterbury_southland)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>canterbury_southland_height <span class="op">=</span> nz_height[sel]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>canterbury_southland_height</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">t50_fid</th>
<th data-quarto-table-cell-role="th">elevation</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2353944</td>
<td>2723</td>
<td>POINT (1204142.603 5049971.287)</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">4</td>
<td>2362630</td>
<td>2749</td>
<td>POINT (1378169.600 5158491.453)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">93</td>
<td>2380300</td>
<td>2711</td>
<td>POINT (1654213.379 5349962.973)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">94</td>
<td>2380308</td>
<td>2885</td>
<td>POINT (1654898.622 5350462.779)</td>
</tr>
</tbody>
</table>

<p>71 rows √ó 3 columns</p>
</div>
</div>
</div>
<p>or, alternatively, we can use the <code>.isin</code> function to filter the regions and use <code>.overlay</code> to calculate the pairwise intersection between the <code>canterbury_southland</code> GeoDataFrame (with two rows for Canterbury and Southland, respectively) and the <code>nz_height</code> GeoDataFrame:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>canterbury_southland <span class="op">=</span> nz[nz[<span class="st">'Name'</span>].isin([<span class="st">'Canterbury'</span>, <span class="st">'Southland'</span>])]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>canterbury_southland</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>nz_height.overlay(canterbury_southland)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">t50_fid</th>
<th data-quarto-table-cell-role="th">elevation</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">Median_income</th>
<th data-quarto-table-cell-role="th">Sex_ratio</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2353944</td>
<td>2723</td>
<td>Southland</td>
<td>...</td>
<td>29500</td>
<td>0.978507</td>
<td>POINT (1204142.603 5049971.287)</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2362630</td>
<td>2749</td>
<td>Canterbury</td>
<td>...</td>
<td>30100</td>
<td>0.975327</td>
<td>POINT (1378169.600 5158491.453)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">69</td>
<td>2380300</td>
<td>2711</td>
<td>Canterbury</td>
<td>...</td>
<td>30100</td>
<td>0.975327</td>
<td>POINT (1654213.379 5349962.973)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">70</td>
<td>2380308</td>
<td>2885</td>
<td>Canterbury</td>
<td>...</td>
<td>30100</td>
<td>0.975327</td>
<td>POINT (1654898.622 5350462.779)</td>
</tr>
</tbody>
</table>

<p>71 rows √ó 9 columns</p>
</div>
</div>
</div>
<p>The resulting subset is shown in <a href="#fig-spatial-subset2">Figure&nbsp;<span class="quarto-unresolved-ref">fig-spatial-subset2</span></a>:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> nz.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>nz_height.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> nz.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>canterbury_southland.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'grey'</span>, edgecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>canterbury_southland_height.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Subset (intersects)'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-spatial-subset2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-spatial-subset2-output-1.png" width="579" height="374" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.3: Spatial subsetting of points by intersection with more that one polygon</figcaption>
</figure>
</div>
</div>
</div>
<p>The next section further explores different types of spatial relation, also known as binary predicates (of which <code>.intersects</code> and <code>.disjoint</code> are two examples), that can be used to identify whether or not two features are spatially related or not.</p>
</section>
<section id="sec-topological-relations" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="sec-topological-relations"><span class="header-section-number">3.3.2</span> Topological relations</h3>
<!--toDo: references should be fixed-->
<p>Topological relations describe the spatial relationships between objects. ‚ÄúBinary topological relationships‚Äù, to give them their full name, are logical statements (in that the answer can only be <code>True</code> or <code>False</code>) about the spatial relationships between two objects defined by ordered sets of points (typically forming points, lines and polygons) in two or more dimensions (Egenhofer and Herring 1990). That may sound rather abstract and, indeed, the definition and classification of topological relations is based on mathematical foundations first published in book form in 1966 (Spanier 1995), with the field of algebraic topology continuing into the 21st century (Dieck 2008).</p>
<p>Despite their mathematical origins, topological relations can be understood intuitively with reference to visualizations of commonly used functions that test for common types of spatial relationships. <!--toDo: update references to figures--> Figure 4.2 shows a variety of geometry pairs and their associated relations. The third and fourth pairs in Figure 4.2 (from left to right and then down) demonstrate that, for some relations, order is important: while the relations equals, intersects, crosses, touches and overlaps are symmetrical, meaning that if function(x, y) is true, function(y, x) will also by true, relations in which the order of the geometries are important such as contains and within are not. Notice that each geometry pair has a ‚ÄúDE-9IM‚Äù string such as FF2F11212, described in the next section.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://r.geocompx.org/04-spatial-operations_files/figure-html/relations-1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Topological relations between vector geometries, inspired by Figures 1 and 2 in Egenhofer and Herring (1990). The relations for which the function(x, y) is true are printed for each geometry pair, with x represented in pink and y represented in blue. <!--toDo: move the used images from geocompr to the geocompy repo (this will make it more stable)--> The nature of the spatial relationship for each pair is described by the Dimensionally Extended 9-Intersection Model string.</figcaption>
</figure>
</div>
<p>In <strong>shapely</strong>, functions testing for different types of topological relations are known as <a href="https://shapely.readthedocs.io/en/stable/manual.html#relationships">‚Äúrelationships‚Äù</a>. To see how topological relations work in practice, let‚Äôs create a simple reproducible example, building on the relations illustrated in Figure 4.2 and consolidating knowledge of how vector geometries are represented from a previous chapter (<a href="#sec-geometry-columns"><span class="quarto-unresolved-ref">sec-geometry-columns</span></a> and <a href="#sec-geometries"><span class="quarto-unresolved-ref">sec-geometries</span></a>):</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> gpd.GeoSeries([</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  shapely.Point(<span class="fl">0.2</span>,<span class="fl">0.1</span>), </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  shapely.Point(<span class="fl">0.7</span>,<span class="fl">0.2</span>), </span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  shapely.Point(<span class="fl">0.4</span>,<span class="fl">0.8</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>line <span class="op">=</span> gpd.GeoSeries([</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  shapely.LineString([(<span class="fl">0.4</span>,<span class="fl">0.2</span>), (<span class="dv">1</span>,<span class="fl">0.5</span>)])</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>poly <span class="op">=</span> gpd.GeoSeries([</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  shapely.Polygon([(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="fl">0.5</span>), (<span class="dv">0</span>,<span class="dv">0</span>)])</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The resulting <code>GeoSeries</code> named <code>points</code>, <code>line</code>, and <code>poly</code> are visualized as follows:</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> poly.plot(color<span class="op">=</span><span class="st">'grey'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> line.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>points.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x, y, label <span class="kw">in</span> <span class="bu">zip</span>(points.x, points.y, [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]):</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    ax.annotate(label, xy<span class="op">=</span>(x, y), xytext<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>), weight<span class="op">=</span><span class="st">'bold'</span>, textcoords<span class="op">=</span><span class="st">"offset points"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-spatial-relations-geoms" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-spatial-relations-geoms-output-1.png" width="419" height="411" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.4: Points, line and polygon objects arranged to illustrate topological relations</figcaption>
</figure>
</div>
</div>
</div>
<p>A simple query is: which of the points in <code>points</code> intersect in some way with polygon <code>poly</code>? The question can be answered by inspection (points 1 and 3 are touching and within the polygon, respectively). This question can be answered with the <code>.intersects</code> method, which reports whether or not each geometry in a <code>GeoSeries</code> (<code>points</code>) intersects with a single <code>shapely</code> geometry (<code>poly.iloc[0]</code>). When both inputs are a <code>GeoSeries</code> object, a pairwise evaluation takes place between geometries aligned by index (<code>align=True</code>, the default) or by position (<code>align=False</code>):</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>points.intersects(poly.iloc[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>0     True
1    False
2     True
dtype: bool</code></pre>
</div>
</div>
<p>The result shown above is a boolean <code>Series</code>. Its contents should match your intuition: positive (<code>True</code>) results are returned for the first and third point, and a negative result (<code>False</code>) for the second are outside the polygon‚Äôs border. Each value in this <code>Series</code> represents a feature in the first input (<code>points</code>).</p>
<p>The <code>.apply</code> method can be used to obtain a matrix of <em>pairwise</em> results. In this case, the result is a <code>DataFrame</code>, where each row represents a <code>points</code> geometry and each column represents a <code>poly</code> geometry. We‚Äôll add another polygon to demonstrate:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>poly <span class="op">=</span> gpd.GeoSeries([</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  shapely.Polygon([(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">1</span>,<span class="fl">0.5</span>), (<span class="dv">0</span>,<span class="dv">0</span>)]),</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  shapely.Polygon([(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="fl">0.5</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="dv">0</span>)])</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>points.<span class="bu">apply</span>(<span class="kw">lambda</span> x: poly.intersects(x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">0</th>
<th data-quarto-table-cell-role="th">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>True</td>
<td>True</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>False</td>
<td>True</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>True</td>
<td>False</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The <code>.intersects</code> method returns <code>True</code> even in cases where the features just touch: intersects is a ‚Äòcatch-all‚Äô topological operation which identifies many types of spatial relation, as illustrated in Figure 4.2. More restrictive questions include which points lie within the polygon, and which features are on or contain a shared boundary with it? These can be answered as follows:</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>points.within(poly.iloc[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>0    False
1    False
2     True
dtype: bool</code></pre>
</div>
</div>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>points.touches(poly.iloc[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>0     True
1    False
2    False
dtype: bool</code></pre>
</div>
</div>
<p>Note that although the first point touches the boundary polygon, it is not within it; the third point is within the polygon but does not touch any part of its border. The opposite of <code>.intersects</code> is <code>.disjoint</code>, which returns only objects that do not spatially relate in any way to the selecting object:</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>points.disjoint(poly.iloc[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>0    False
1     True
2    False
dtype: bool</code></pre>
</div>
</div>
<p>Another useful type of relation is ‚Äúwithin distance‚Äù, where we detect features that intersect with the target buffered by particular distance. Buffer distance determines how close target objects need to be before they are selected. This can be done by literally buffering (<a href="#sec-geometries"><span class="quarto-unresolved-ref">sec-geometries</span></a>) the target geometry, and evaluating intersection (<code>.intersects</code>, see above). Another way is to calculate the distances and compare them to the distance threshold:</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>points.distance(poly.iloc[<span class="dv">0</span>]) <span class="op">&lt;</span> <span class="fl">0.2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>0    True
1    True
2    True
dtype: bool</code></pre>
</div>
</div>
<p>Note that although point 2 is more than 0.2 units of distance from the nearest vertex of <code>poly</code>, it is still selected when the distance is set to 0.2. This is because distance is measured to the nearest edge, in this case the part of the the polygon that lies directly above point 2 in Figure 4.2. We can verify the actual distance between point 2 and the polygon is 0.13, as follows:</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>points.iloc[<span class="dv">1</span>].distance(poly.iloc[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>0.13416407864998736</code></pre>
</div>
</div>
</section>
<section id="de-9im-strings" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="de-9im-strings"><span class="header-section-number">3.3.3</span> DE-9IM strings</h3>
<p>To complete‚Ä¶</p>
</section>
<section id="sec-spatial-joining" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="sec-spatial-joining"><span class="header-section-number">3.3.4</span> Spatial joining</h3>
<p>Joining two non-spatial datasets relies on a shared ‚Äòkey‚Äô variable, as described in <a href="#sec-vector-attribute-joining"><span class="quarto-unresolved-ref">sec-vector-attribute-joining</span></a>. Spatial data joining applies the same concept, but instead relies on spatial relations, described in the previous section. As with attribute data, joining adds new columns to the target object (the argument x in joining functions), from a source object (y).</p>
<p>The process is illustrated by the following example: imagine you have ten points randomly distributed across the Earth‚Äôs surface and you ask, for the points that are on land, which countries are they in? Implementing this idea in a reproducible example will build your geographic data handling skills and show how spatial joins work. The starting point is to create points that are randomly scattered over the Earth‚Äôs surface:</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">11</span>)  <span class="co">## set seed for reproducibility</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>bb <span class="op">=</span> world.total_bounds  <span class="co">## the world's bounds</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.uniform(low<span class="op">=</span>bb[<span class="dv">0</span>], high<span class="op">=</span>bb[<span class="dv">2</span>], size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.random.uniform(low<span class="op">=</span>bb[<span class="dv">1</span>], high<span class="op">=</span>bb[<span class="dv">3</span>], size<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>random_points <span class="op">=</span> gpd.points_from_xy(x, y, crs<span class="op">=</span><span class="dv">4326</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>random_points <span class="op">=</span> gpd.GeoSeries(random_points)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>random_points <span class="op">=</span> gpd.GeoDataFrame({<span class="st">'geometry'</span>: random_points})</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>random_points</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>POINT (-115.10291 36.78178)</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>POINT (-172.98891 -71.02938)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">8</td>
<td>POINT (159.05039 -34.99599)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">9</td>
<td>POINT (126.28622 -62.49509)</td>
</tr>
</tbody>
</table>

<p>10 rows √ó 1 columns</p>
</div>
</div>
</div>
<p>The scenario illustrated in <a href="#fig-spatial-join">Figure&nbsp;<span class="quarto-unresolved-ref">fig-spatial-join</span></a> shows that the <code>random_points</code> object (top left) lacks attribute data, while the world (top right) has attributes, including country names shown for a sample of countries in the legend. Spatial joins are implemented with <code>gpd.sjoin</code>, as illustrated in the code chunk below. The output is the <code>random_joined</code> object which is illustrated in <a href="#fig-spatial-join">Figure&nbsp;<span class="quarto-unresolved-ref">fig-spatial-join</span></a> (bottom left). Before creating the joined dataset, we use spatial subsetting to create world_random, which contains only countries that contain random points, to verify the number of country names returned in the joined dataset should be four (see the top right panel of <a href="#fig-spatial-join">Figure&nbsp;<span class="quarto-unresolved-ref">fig-spatial-join</span></a>).</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Subset</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>world_random <span class="op">=</span> world[world.intersects(random_points.unary_union)]</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>world_random</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">iso_a2</th>
<th data-quarto-table-cell-role="th">name_long</th>
<th data-quarto-table-cell-role="th">continent</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">lifeExp</th>
<th data-quarto-table-cell-role="th">gdpPercap</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>US</td>
<td>United States</td>
<td>North America</td>
<td>...</td>
<td>78.841463</td>
<td>51921.984639</td>
<td>MULTIPOLYGON (((-171.73166 63.7...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">18</td>
<td>RU</td>
<td>Russian Federation</td>
<td>Europe</td>
<td>...</td>
<td>70.743659</td>
<td>25284.586202</td>
<td>MULTIPOLYGON (((-180.00000 64.9...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">52</td>
<td>ML</td>
<td>Mali</td>
<td>Africa</td>
<td>...</td>
<td>57.007000</td>
<td>1865.160622</td>
<td>MULTIPOLYGON (((-11.51394 12.44...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">159</td>
<td>AQ</td>
<td>Antarctica</td>
<td>Antarctica</td>
<td>...</td>
<td>NaN</td>
<td>NaN</td>
<td>MULTIPOLYGON (((-180.00000 -89....</td>
</tr>
</tbody>
</table>

<p>4 rows √ó 11 columns</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Spatial join</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>random_joined <span class="op">=</span> gpd.sjoin(random_points, world, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>random_joined</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">index_right</th>
<th data-quarto-table-cell-role="th">iso_a2</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">pop</th>
<th data-quarto-table-cell-role="th">lifeExp</th>
<th data-quarto-table-cell-role="th">gdpPercap</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>POINT (-115.10291 36.78178)</td>
<td>4.0</td>
<td>US</td>
<td>...</td>
<td>318622525.0</td>
<td>78.841463</td>
<td>51921.984639</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>POINT (-172.98891 -71.02938)</td>
<td>NaN</td>
<td>NaN</td>
<td>...</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">8</td>
<td>POINT (159.05039 -34.99599)</td>
<td>NaN</td>
<td>NaN</td>
<td>...</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">9</td>
<td>POINT (126.28622 -62.49509)</td>
<td>NaN</td>
<td>NaN</td>
<td>...</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>10 rows √ó 12 columns</p>
</div>
</div>
</div>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> world.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>random_points.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> world.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>][<span class="dv">1</span>])</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>world_random.plot(ax<span class="op">=</span>base, column<span class="op">=</span><span class="st">'name_long'</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> world.plot(color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>][<span class="dv">0</span>])</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>random_joined.geometry.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'grey'</span>)<span class="op">;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>random_joined.plot(ax<span class="op">=</span>base, column<span class="op">=</span><span class="st">'name_long'</span>, legend<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>fig.delaxes(axes[<span class="dv">1</span>][<span class="dv">1</span>])<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-spatial-join" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-spatial-join-output-1.png" width="652" height="335" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.5: Illustration of a spatial join. A new attribute variable is added to random points (top left) from source world object (top right) resulting in the data represented in the final panel.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="non-overlapping-joins" class="level3" data-number="3.3.5">
<h3 data-number="3.3.5" class="anchored" data-anchor-id="non-overlapping-joins"><span class="header-section-number">3.3.5</span> Non-overlapping joins</h3>
<p>Sometimes two geographic datasets do not touch but still have a strong geographic relationship. The datasets <code>cycle_hire</code> and <code>cycle_hire_osm</code>, provide a good example. Plotting them shows that they are often closely related but they do not touch, as shown in <a href="#fig-cycle-hire">Figure&nbsp;<span class="quarto-unresolved-ref">fig-cycle-hire</span></a>:</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> cycle_hire.plot(edgecolor<span class="op">=</span><span class="st">'blue'</span>, color<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>cycle_hire_osm.plot(ax<span class="op">=</span>base, edgecolor<span class="op">=</span><span class="st">'red'</span>, color<span class="op">=</span><span class="st">'none'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-cycle-hire" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-cycle-hire-output-1.png" width="440" height="276" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.6: The spatial distribution of cycle hire points in London based on official data (blue) and OpenStreetMap data (red).</figcaption>
</figure>
</div>
</div>
</div>
<p>We can check if any of the points are the same by creating a pairwise boolean matrix of <code>.intersects</code> relations, then evaluating whether any of the values in it is <code>True</code>. Note that the <code>.to_numpy</code> method is applied to go from a <code>DataFrame</code> to a <code>numpy</code> array, for which <code>.any</code> gives a global rather than a row-wise summary, which is what we want in this case:</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> cycle_hire[<span class="st">'geometry'</span>].<span class="bu">apply</span>(</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">lambda</span> x: cycle_hire_osm[<span class="st">'geometry'</span>].intersects(x)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>m.to_numpy().<span class="bu">any</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>False</code></pre>
</div>
</div>
<p>Imagine that we need to join the capacity variable in <code>cycle_hire_osm</code> onto the official ‚Äòtarget‚Äô data contained in <code>cycle_hire</code>. This is when a non-overlapping join is needed. Spatial join (<code>gpd.sjoin</code>) along with buffered geometries can be used to do that. This is demonstrated below, using a threshold distance of 20 <span class="math inline">\(m\)</span>. Note that we transform the data to a projected CRS (<code>27700</code>) to use real buffer distances, in meters.</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>crs <span class="op">=</span> <span class="dv">27700</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>cycle_hire_buffers <span class="op">=</span> cycle_hire.copy().to_crs(crs)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>cycle_hire_buffers[<span class="st">'geometry'</span>] <span class="op">=</span> cycle_hire_buffers.<span class="bu">buffer</span>(<span class="dv">20</span>)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> gpd.sjoin(</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  cycle_hire_buffers, </span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  cycle_hire_osm.to_crs(crs)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">name_left</th>
<th data-quarto-table-cell-role="th">area</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">capacity</th>
<th data-quarto-table-cell-role="th">cyclestreets_id</th>
<th data-quarto-table-cell-role="th">description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>River Street</td>
<td>Clerkenwell</td>
<td>...</td>
<td>9.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2</td>
<td>Phillimore Gardens</td>
<td>Kensington</td>
<td>...</td>
<td>27.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">729</td>
<td>765</td>
<td>Ranelagh Gardens</td>
<td>Fulham</td>
<td>...</td>
<td>29.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">737</td>
<td>773</td>
<td>Tallis Street</td>
<td>Temple</td>
<td>...</td>
<td>14.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>458 rows √ó 12 columns</p>
</div>
</div>
</div>
<p>Note that the number of rows in the joined result is greater than the target. This is because some cycle hire stations in <code>cycle_hire_buffers</code> have multiple matches in <code>cycle_hire_osm</code>. To aggregate the values for the overlapping points and return the mean, we can use the aggregation methods learned in <a href="#sec-vector-attribute-aggregation"><span class="quarto-unresolved-ref">sec-vector-attribute-aggregation</span></a>, resulting in an object with the same number of rows as the target. We also go back from buffers to points using <code>.centroid</code>:</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> z[[<span class="st">'id'</span>, <span class="st">'capacity'</span>, <span class="st">'geometry'</span>]] <span class="op">\</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    .dissolve(by<span class="op">=</span><span class="st">'id'</span>, aggfunc<span class="op">=</span><span class="st">'mean'</span>) <span class="op">\</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    .reset_index()</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>z[<span class="st">'geometry'</span>] <span class="op">=</span> z.centroid</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">capacity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>POINT (531203.517 182832.066)</td>
<td>9.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2</td>
<td>POINT (525208.067 179391.922)</td>
<td>27.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">436</td>
<td>765</td>
<td>POINT (524652.998 175817.001)</td>
<td>29.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">437</td>
<td>773</td>
<td>POINT (531435.032 180916.010)</td>
<td>14.0</td>
</tr>
</tbody>
</table>

<p>438 rows √ó 3 columns</p>
</div>
</div>
</div>
<p>The capacity of nearby stations can be verified by comparing a plot of the capacity of the source <code>cycle_hire_osm</code> data with the results in this new object <code>z</code> (<a href="#fig-cycle-hire-z">Figure&nbsp;<span class="quarto-unresolved-ref">fig-cycle-hire-z</span></a>):</p>
<div>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Input</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">3</span>))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>cycle_hire_osm.plot(column<span class="op">=</span><span class="st">'capacity'</span>, legend<span class="op">=</span><span class="va">True</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Join result</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">3</span>))</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>z.plot(column<span class="op">=</span><span class="st">'capacity'</span>, legend<span class="op">=</span><span class="va">True</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-cycle-hire-z" class="cell quarto-layout-panel" data-execution_count="32">
<figure class="figure">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 49.4%;justify-content: center;">
<div id="fig-cycle-hire-z-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-cycle-hire-z-output-1.png" class="img-fluid figure-img" data-ref-parent="fig-cycle-hire-z" width="484"></p>
<figcaption class="figure-caption">(a) Input</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.6%;justify-content: center;">
<div id="fig-cycle-hire-z-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-cycle-hire-z-output-2.png" class="img-fluid figure-img" data-ref-parent="fig-cycle-hire-z" width="496"></p>
<figcaption class="figure-caption">(b) Join result</figcaption>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Figure&nbsp;3.7: Non-overlapping join</figcaption><p></p>
</figure>
</div>
</div>
</section>
<section id="spatial-aggregation" class="level3" data-number="3.3.6">
<h3 data-number="3.3.6" class="anchored" data-anchor-id="spatial-aggregation"><span class="header-section-number">3.3.6</span> Spatial aggregation</h3>
<p>As with attribute data aggregation, spatial data aggregation condenses data: aggregated outputs have fewer rows than non-aggregated inputs. Statistical aggregating functions, such as mean, average, or sum, summarise multiple values of a variable, and return a single value per grouping variable. <a href="#sec-vector-attribute-aggregation"><span class="quarto-unresolved-ref">sec-vector-attribute-aggregation</span></a> demonstrated how the <code>.groupby</code> method, combined with summary functions such as <code>.sum</code>, condense data based on attribute variables. This section shows how grouping by spatial objects can be acheived using spatial joins combined with non-spatial aggregation.</p>
<p>Returning to the example of New Zealand, imagine you want to find out the average height of high points in each region. It is the geometry of the source (<code>nz</code>) that defines how values in the target object (<code>nz_height</code>) are grouped. This can be done in three steps:</p>
<ol type="1">
<li>Figuring out which <code>nz</code> region each <code>nz_height</code> point falls in‚Äîusing <code>gpd.sjoin</code></li>
<li>Summarizing the average elevation per region‚Äîusing <code>.groupby</code> and <code>.mean</code></li>
<li>Joining the result back to <code>nz</code>‚Äîusing <code>pd.merge</code></li>
</ol>
<p>First, we ‚Äòattach‚Äô the region classification of each point, using spatial join. Note that we are using the minimal set of columns required: the geometries (for the spatial join to work), the point elevation (to later calculate an average), and the region name (to use as key when joining the results back to <code>nz</code>).</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>nz_height2 <span class="op">=</span> gpd.sjoin(</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  nz_height[[<span class="st">'elevation'</span>, <span class="st">'geometry'</span>]], </span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  nz[[<span class="st">'Name'</span>, <span class="st">'geometry'</span>]], </span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  how<span class="op">=</span><span class="st">'left'</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>nz_height2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">elevation</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">index_right</th>
<th data-quarto-table-cell-role="th">Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2723</td>
<td>POINT (1204142.603 5049971.287)</td>
<td>12</td>
<td>Southland</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2820</td>
<td>POINT (1234725.325 5048309.302)</td>
<td>11</td>
<td>Otago</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">99</td>
<td>2720</td>
<td>POINT (1822262.592 5650428.656)</td>
<td>2</td>
<td>Waikato</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">100</td>
<td>2732</td>
<td>POINT (1822492.184 5650492.304)</td>
<td>2</td>
<td>Waikato</td>
</tr>
</tbody>
</table>

<p>101 rows √ó 4 columns</p>
</div>
</div>
</div>
<p>Second, we calculate the average elevation:</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>nz_height3 <span class="op">=</span> nz_height2.groupby(<span class="st">'Name'</span>)[[<span class="st">'elevation'</span>]].mean()</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>nz_height3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">elevation</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Canterbury</td>
<td>2994.600000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Manawatu-Wanganui</td>
<td>2777.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Waikato</td>
<td>2734.333333</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">West Coast</td>
<td>2889.454545</td>
</tr>
</tbody>
</table>

<p>7 rows √ó 1 columns</p>
</div>
</div>
</div>
<p>The third and final step is joining the averages with the <code>nz</code> layer:</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>nz_height4 <span class="op">=</span> pd.merge(nz[[<span class="st">'Name'</span>, <span class="st">'geometry'</span>]], nz_height3, on<span class="op">=</span><span class="st">'Name'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>nz_height4</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">elevation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Northland</td>
<td>MULTIPOLYGON (((1745493.196 600...</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Auckland</td>
<td>MULTIPOLYGON (((1803822.103 590...</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">14</td>
<td>Nelson</td>
<td>MULTIPOLYGON (((1624866.279 541...</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">15</td>
<td>Marlborough</td>
<td>MULTIPOLYGON (((1686901.914 535...</td>
<td>2720.0</td>
</tr>
</tbody>
</table>

<p>16 rows √ó 3 columns</p>
</div>
</div>
</div>
<p>We now have create the <code>nz_height4</code> layer, which gives the average <code>nz_height</code> elevation value per polygon. The result is shown in <a href="#fig-nz-avg-nz-height">Figure&nbsp;<span class="quarto-unresolved-ref">fig-nz-avg-nz-height</span></a>. Note that the <code>missing_kwds</code> part determines the style of geometries where the symbology attribute (<code>elevation</code>) is missing, because the were no <code>nz_height</code> points overlapping with them. The default is to omit them, which is usually not what we want. With <code>{'color':'none','edgecolor':'black'}</code>, those polygons are shown with black outline and no fill.</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>nz_height4.plot(</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  column<span class="op">=</span><span class="st">'elevation'</span>, </span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  legend<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  cmap<span class="op">=</span><span class="st">'Blues'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>,</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  missing_kwds<span class="op">=</span>{<span class="st">'color'</span>: <span class="st">'none'</span>, <span class="st">'edgecolor'</span>: <span class="st">'black'</span>}</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-nz-avg-nz-height" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-nz-avg-nz-height-output-1.png" width="386" height="442" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.8: Average height of the top 101 high points across the regions of New Zealand</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="joining-incongruent-layers" class="level3" data-number="3.3.7">
<h3 data-number="3.3.7" class="anchored" data-anchor-id="joining-incongruent-layers"><span class="header-section-number">3.3.7</span> Joining incongruent layers</h3>
<p>Spatial congruence is an important concept related to spatial aggregation. An aggregating object (which we will refer to as <code>y</code>) is congruent with the target object (<code>x</code>) if the two objects have shared borders. Often this is the case for administrative boundary data, whereby larger units‚Äîsuch as Middle Layer Super Output Areas (MSOAs) in the UK or districts in many other European countries‚Äîare composed of many smaller units.</p>
<p>Incongruent aggregating objects, by contrast, do not share common borders with the target (Qiu, Zhang, and Zhou 2012). This is problematic for spatial aggregation (and other spatial operations) illustrated in <a href="#fig-nz-and-grid">Figure&nbsp;<span class="quarto-unresolved-ref">fig-nz-and-grid</span></a>: aggregating the centroid of each sub-zone will not return accurate results. Areal interpolation overcomes this issue by transferring values from one set of areal units to another, using a range of algorithms including simple area weighted approaches and more sophisticated approaches such as ‚Äòpycnophylactic‚Äô methods (Tobler 1979).</p>
<p>To demonstrate, we will create a ‚Äúsynthetic‚Äù layer comprising a <a href="https://gis.stackexchange.com/questions/322589/rasterizing-polygon-grid-in-python-geopandas-rasterio">regular grid</a> of rectangles of size <span class="math inline">\(100\times100\)</span> <span class="math inline">\(km\)</span>, covering the extent of the <code>nz</code> layer:</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>xmin, ymin, xmax, ymax <span class="op">=</span> nz.total_bounds</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> <span class="dv">100000</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">int</span>(np.floor(xmin)), <span class="bu">int</span>(np.ceil(xmax<span class="op">+</span>res)), res))</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>rows <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">int</span>(np.floor(ymin)), <span class="bu">int</span>(np.ceil(ymax<span class="op">+</span>res)), res))</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>rows.reverse()</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>polygons <span class="op">=</span> []</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> cols:</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> rows:</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>        polygons.append( shapely.Polygon([(x,y), (x<span class="op">+</span>res, y), (x<span class="op">+</span>res, y<span class="op">-</span>res), (x, y<span class="op">-</span>res)]) )</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> gpd.GeoDataFrame({<span class="st">'geometry'</span>: polygons}, crs<span class="op">=</span>nz.crs)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> grid.intersects(shapely.box(<span class="op">*</span>nz.total_bounds))</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> grid[sel]</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>grid[<span class="st">'id'</span>] <span class="op">=</span> grid.index</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>grid</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>POLYGON ((1090143.000 6248536.0...</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>POLYGON ((1090143.000 6148536.0...</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">157</td>
<td>POLYGON ((1990143.000 4948536.0...</td>
<td>157</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">158</td>
<td>POLYGON ((1990143.000 4848536.0...</td>
<td>158</td>
</tr>
</tbody>
</table>

<p>150 rows √ó 2 columns</p>
</div>
</div>
</div>
<p>as shown in <a href="#fig-nz-and-grid">Figure&nbsp;<span class="quarto-unresolved-ref">fig-nz-and-grid</span></a>.</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> grid.plot(color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'grey'</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>nz.plot(ax<span class="op">=</span>base, column<span class="op">=</span><span class="st">'Population'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>, legend<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">'viridis_r'</span>)<span class="op">;</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>base.set_title(<span class="st">'Population'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-nz-and-grid" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-nz-and-grid-output-1.png" width="364" height="448" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.9: The nz layer and a regular grid of rectangles</figcaption>
</figure>
</div>
</div>
</div>
<p>Our goal, now, is to ‚Äútransfer‚Äù the <code>Population</code> attribute to the rectangular grid polygons, which is an example of a join between incongruent layers. To do that, we basically need to calculate‚Äìfor each <code>grid</code> cell‚Äîthe weighted sum of the population in <code>nz</code> polygons coinciding with that cell. The weights in the weighted sum calculation are the ratios between the area of the coinciding ‚Äúpart‚Äù out of the entire <code>nz</code> polygon. That is, we (inevitably) assume that the population in each <code>nz</code> polygon is equally distributed across space, therefore a partial <code>nz</code> polygon contains the respective partial population size.</p>
<p>We start with calculating the entire area of each <code>nz</code> polygon, as follows, using the <code>.area</code> method (see <a href="#sec-area-length"><span class="quarto-unresolved-ref">sec-area-length</span></a>):</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>nz[<span class="st">'area'</span>] <span class="op">=</span> nz.area</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>nz</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="39">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Island</th>
<th data-quarto-table-cell-role="th">Land_area</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">Sex_ratio</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">area</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Northland</td>
<td>North</td>
<td>12500.561149</td>
<td>...</td>
<td>0.942453</td>
<td>MULTIPOLYGON (((1745493.196 600...</td>
<td>1.289058e+10</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Auckland</td>
<td>North</td>
<td>4941.572557</td>
<td>...</td>
<td>0.944286</td>
<td>MULTIPOLYGON (((1803822.103 590...</td>
<td>4.911565e+09</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">14</td>
<td>Nelson</td>
<td>South</td>
<td>422.195242</td>
<td>...</td>
<td>0.925967</td>
<td>MULTIPOLYGON (((1624866.279 541...</td>
<td>4.080754e+08</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">15</td>
<td>Marlborough</td>
<td>South</td>
<td>10457.745485</td>
<td>...</td>
<td>0.957792</td>
<td>MULTIPOLYGON (((1686901.914 535...</td>
<td>1.046485e+10</td>
</tr>
</tbody>
</table>

<p>16 rows √ó 8 columns</p>
</div>
</div>
</div>
<p>Next, we use the <code>.overlay</code> method to calculate the pairwise intersections between <code>nz</code> and <code>grid</code>, hereby named <code>nz_grid</code>. We also calculate the area of the intersections, hereby named <code>area_sub</code>. If an <code>nz</code> polygon was completely within a single <code>grid</code> polygon, then <code>area_sub</code> is going to be equal to <code>area</code>; otherwise, it is going to be smaller:</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>nz_grid <span class="op">=</span> nz.overlay(grid)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>nz_grid <span class="op">=</span> nz_grid[[<span class="st">'id'</span>, <span class="st">'area'</span>, <span class="st">'Population'</span>, <span class="st">'geometry'</span>]]</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>nz_grid[<span class="st">'area_sub'</span>] <span class="op">=</span> nz_grid.area</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>nz_grid</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="40">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">area</th>
<th data-quarto-table-cell-role="th">Population</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">area_sub</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>64</td>
<td>1.289058e+10</td>
<td>175500.0</td>
<td>POLYGON ((1586362.965 6168009.0...</td>
<td>3.231015e+08</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>80</td>
<td>1.289058e+10</td>
<td>175500.0</td>
<td>POLYGON ((1590143.000 6162776.6...</td>
<td>4.612641e+08</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">108</td>
<td>87</td>
<td>4.080754e+08</td>
<td>51400.0</td>
<td>POLYGON ((1649908.695 5455398.2...</td>
<td>1.716260e+07</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">109</td>
<td>87</td>
<td>1.046485e+10</td>
<td>46200.0</td>
<td>MULTIPOLYGON (((1678688.086 545...</td>
<td>4.526248e+08</td>
</tr>
</tbody>
</table>

<p>110 rows √ó 5 columns</p>
</div>
</div>
</div>
<p>The resulting layer <code>nz_grid</code> is shown in <a href="#fig-nz-and-grid2">Figure&nbsp;<span class="quarto-unresolved-ref">fig-nz-and-grid2</span></a>.</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> grid.plot(color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'grey'</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>nz_grid.plot(ax<span class="op">=</span>base, column<span class="op">=</span><span class="st">'Population'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>, legend<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">'viridis_r'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-nz-and-grid2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-nz-and-grid2-output-1.png" width="364" height="442" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.10: The nz layer and a regular grid of rectangles: after an overlay operation</figcaption>
</figure>
</div>
</div>
</div>
<p>Note that each of the ‚Äúintersections‚Äù still holds the <code>Population</code> attribute of its ‚Äúorigin‚Äù feature of <code>nz</code>, as depicted in <a href="#fig-nz-and-grid2">Figure&nbsp;<span class="quarto-unresolved-ref">fig-nz-and-grid2</span></a>. The real population size of each <code>nz_grid</code> feature, however, is smaller (or equal), depending on the geographic area proportion that it occupies out of the original <code>nz</code> feature. To make the ‚Äúcorrection‚Äù, we first calculate the ratio (<code>area_prop</code>) and then multiply it by the population. The new (lowercase) attribute <code>population</code> now has the correct estimate of population sizes in <code>nz_grid</code>:</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>nz_grid[<span class="st">'area_prop'</span>] <span class="op">=</span> nz_grid[<span class="st">'area_sub'</span>] <span class="op">/</span> nz_grid[<span class="st">'area'</span>]</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>nz_grid[<span class="st">'population'</span>] <span class="op">=</span> nz_grid[<span class="st">'Population'</span>] <span class="op">*</span> nz_grid[<span class="st">'area_prop'</span>]</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>nz_grid</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">area</th>
<th data-quarto-table-cell-role="th">Population</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">area_sub</th>
<th data-quarto-table-cell-role="th">area_prop</th>
<th data-quarto-table-cell-role="th">population</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>64</td>
<td>1.289058e+10</td>
<td>175500.0</td>
<td>...</td>
<td>3.231015e+08</td>
<td>0.025065</td>
<td>4398.897141</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>80</td>
<td>1.289058e+10</td>
<td>175500.0</td>
<td>...</td>
<td>4.612641e+08</td>
<td>0.035783</td>
<td>6279.925114</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">108</td>
<td>87</td>
<td>4.080754e+08</td>
<td>51400.0</td>
<td>...</td>
<td>1.716260e+07</td>
<td>0.042057</td>
<td>2161.752203</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">109</td>
<td>87</td>
<td>1.046485e+10</td>
<td>46200.0</td>
<td>...</td>
<td>4.526248e+08</td>
<td>0.043252</td>
<td>1998.239223</td>
</tr>
</tbody>
</table>

<p>110 rows √ó 7 columns</p>
</div>
</div>
</div>
<p>What is left to be done is to sum (see <a href="#sec-vector-attribute-aggregation"><span class="quarto-unresolved-ref">sec-vector-attribute-aggregation</span></a>) the population in all parts forming the same grid cell:</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>nz_grid <span class="op">=</span> nz_grid.groupby(<span class="st">'id'</span>)[<span class="st">'population'</span>].<span class="bu">sum</span>().reset_index()</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>nz_grid</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">population</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>11</td>
<td>67.533590</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>12</td>
<td>15339.996965</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">55</td>
<td>149</td>
<td>31284.910446</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">56</td>
<td>150</td>
<td>129.326331</td>
</tr>
</tbody>
</table>

<p>57 rows √ó 2 columns</p>
</div>
</div>
</div>
<p>and join (see <a href="#sec-vector-attribute-joining"><span class="quarto-unresolved-ref">sec-vector-attribute-joining</span></a>) them back to the <code>grid</code> layer:</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pd.merge(grid, nz_grid[[<span class="st">'id'</span>, <span class="st">'population'</span>]], on<span class="op">=</span><span class="st">'id'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>grid</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="44">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">population</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>POLYGON ((1090143.000 6248536.0...</td>
<td>0</td>
<td>NaN</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>POLYGON ((1090143.000 6148536.0...</td>
<td>1</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">148</td>
<td>POLYGON ((1990143.000 4948536.0...</td>
<td>157</td>
<td>NaN</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">149</td>
<td>POLYGON ((1990143.000 4848536.0...</td>
<td>158</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<p>150 rows √ó 3 columns</p>
</div>
</div>
</div>
<p>The final result <code>grid</code>, with the incongruently-joined <code>population</code> attribute from <code>nz</code>, is shown in <a href="#fig-nz-and-grid3">Figure&nbsp;<span class="quarto-unresolved-ref">fig-nz-and-grid3</span></a>.</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> grid.plot(column<span class="op">=</span><span class="st">'population'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>, legend<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">'viridis_r'</span>)<span class="op">;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>nz.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'grey'</span>, legend<span class="op">=</span><span class="va">True</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-nz-and-grid3" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-nz-and-grid3-output-1.png" width="364" height="442" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.11: The nz layer and a regular grid of rectangles: final result</figcaption>
</figure>
</div>
</div>
</div>
<p>We can demonstrate that, expectedly, the summed population in <code>nz</code> and <code>grid</code> is identical, even though the geometry is different (since we created <code>grid</code> to completely cover <code>nz</code>):</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>nz[<span class="st">'Population'</span>].<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="46">
<pre><code>4787200.0</code></pre>
</div>
</div>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>grid[<span class="st">'population'</span>].<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="47">
<pre><code>4787199.999999998</code></pre>
</div>
</div>
<p>The procedure in this section is known as an area-weighted interpolation of a spatially extensive (e.g., population) variable. An area-weighted interpolation of a spatially intensive variable (e.g., population density) is almost identical, except that we would have to calculate the weighted <code>.mean</code> rather than <code>.sum</code>, to preserve the average rather than the sum.</p>
</section>
<section id="distance-relations" class="level3" data-number="3.3.8">
<h3 data-number="3.3.8" class="anchored" data-anchor-id="distance-relations"><span class="header-section-number">3.3.8</span> Distance relations</h3>
<p>While topological relations are binary ‚Äî a feature either intersects with another or does not ‚Äî distance relations are continuous. The distance between two objects is calculated with the <code>distance</code> method. The method is applied on a <code>GeoSeries</code> (or a <code>GeoDataFrame</code>), with the argument being an individual <code>shapely</code> geometry. The result is a <code>Series</code> of pairwise distances.</p>
<p>This is illustrated in the code chunk below, which finds the distance between the three highest point in New Zealand:</p>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>nz_highest <span class="op">=</span> nz_height <span class="op">\</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  .sort_values(by<span class="op">=</span><span class="st">'elevation'</span>, ascending<span class="op">=</span><span class="va">False</span>) <span class="op">\</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  .iloc[:<span class="dv">3</span>, :]</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>nz_highest</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">t50_fid</th>
<th data-quarto-table-cell-role="th">elevation</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">64</td>
<td>2372236</td>
<td>3724</td>
<td>POINT (1369317.630 5169132.284)</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">63</td>
<td>2372235</td>
<td>3717</td>
<td>POINT (1369512.866 5168235.616)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">67</td>
<td>2372252</td>
<td>3688</td>
<td>POINT (1369381.942 5168761.875)</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>and the geographic centroid of the Canterbury region, created in Section 4.2.1:</p>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>canterbury_centroid <span class="op">=</span> canterbury.centroid.iloc[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here are the distances:</p>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>nz_highest.distance(canterbury_centroid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>64    115539.995747
63    115390.248038
67    115493.594066
dtype: float64</code></pre>
</div>
</div>
<p>To obtain a distance matrix, i.e., a pairwise set of distances between all combinations of features in objects <code>x</code> and <code>y</code>, we need to use the <code>.apply</code> method. This is illustrated in the command below, which finds the distances between the first three features in <code>nz_height</code> and the Otago and Canterbury regions of New Zealand represented by the object <code>co</code>:</p>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> nz[<span class="st">'Name'</span>].<span class="bu">str</span>.contains(<span class="st">'Canter|Otag'</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>co <span class="op">=</span> nz[sel]</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>co</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Island</th>
<th data-quarto-table-cell-role="th">Land_area</th>
<th data-quarto-table-cell-role="th">...</th>
<th data-quarto-table-cell-role="th">Sex_ratio</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">area</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">10</td>
<td>Canterbury</td>
<td>South</td>
<td>44504.499091</td>
<td>...</td>
<td>0.975327</td>
<td>MULTIPOLYGON (((1686901.914 535...</td>
<td>4.532656e+10</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">11</td>
<td>Otago</td>
<td>South</td>
<td>31186.309188</td>
<td>...</td>
<td>0.951169</td>
<td>MULTIPOLYGON (((1335204.789 512...</td>
<td>3.190356e+10</td>
</tr>
</tbody>
</table>

<p>2 rows √ó 8 columns</p>
</div>
</div>
</div>
<p>The distance matrix <code>d</code> is obtained as follows (technically speaking, this is a <code>DataFrame</code>). In plain language, we take the geometry from each each row in <code>nz_height.iloc[:3, :]</code>, and apply the <code>.distance</code> method on <code>co</code> with that row as the argument:</p>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> nz_height.iloc[:<span class="dv">3</span>, :].<span class="bu">apply</span>(<span class="kw">lambda</span> x: co.distance(x[<span class="st">'geometry'</span>]), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>d</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="52">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">10</th>
<th data-quarto-table-cell-role="th">11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>123537.158269</td>
<td>15497.717252</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>94282.773074</td>
<td>0.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>93018.560814</td>
<td>0.000000</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Note that the distance between the second and third features in <code>nz_height</code> and the second feature in <code>co</code> is zero. This demonstrates the fact that distances between points and polygons refer to the distance to any part of the polygon: The second and third points in <code>nz_height</code> are in Otago, which can be verified by plotting them:</p>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> co.iloc[[<span class="dv">1</span>]].plot(color<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>nz_height.iloc[<span class="dv">1</span>:<span class="dv">3</span>, :].plot(ax<span class="op">=</span>base)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="04-spatial-operations_files/figure-html/cell-54-output-1.png" width="356" height="442"></p>
</div>
</div>
</section>
</section>
<section id="sec-spatial-ras" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="sec-spatial-ras"><span class="header-section-number">3.4</span> Spatial operations on raster data</h2>
<section id="sec-spatial-subsetting" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="sec-spatial-subsetting"><span class="header-section-number">3.4.1</span> Spatial subsetting</h3>
<p>The previous chapter (Section <a href="#sec-manipulating-raster-objects"><span class="quarto-unresolved-ref">sec-manipulating-raster-objects</span></a>) demonstrated how to retrieve values associated with specific cell IDs or row and column combinations. Raster objects can also be extracted by location (coordinates) and other spatial objects. To use coordinates for subsetting, we can use the <a href="https://rasterio.readthedocs.io/en/stable/api/rasterio.io.html#rasterio.io.DatasetReader.sample"><code>.sample</code></a> method of a <code>rasterio</code> file connection object, combined with a list of coordinate tuples. The methods is demonstrated below to find the value of the cell that covers a point located at coordinates of 0.1, 0.1 in <code>elev</code>. The returned object is a <em>generator</em>:</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>src_elev.sample([(<span class="fl">0.1</span>, <span class="fl">0.1</span>)])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>&lt;generator object sample_gen at 0x7f92758ff320&gt;</code></pre>
</div>
</div>
<p>In case we want all values at once we can apply <code>list</code>. The result is <code>16</code>:</p>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(src_elev.sample([(<span class="fl">0.1</span>, <span class="fl">0.1</span>)]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="55">
<pre><code>[array([16], dtype=uint8)]</code></pre>
</div>
</div>
<p>Another common use case of spatial subsetting is using a boolean mask, based on another raster with the same extent and resolution, or the original one, as illustrated in <a href="#fig-raster-subset">Figure&nbsp;<span class="quarto-unresolved-ref">fig-raster-subset</span></a>. To do that, we ‚Äúerase‚Äù the values in the array of one raster, according to another corresponding ‚Äúmask‚Äù raster. For example, let us read the <code>elev.tif</code> raster array:</p>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>elev <span class="op">=</span> src_elev.read(<span class="dv">1</span>)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>elev</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<pre><code>array([[ 1,  2,  3,  4,  5,  6],
       [ 7,  8,  9, 10, 11, 12],
       [13, 14, 15, 16, 17, 18],
       [19, 20, 21, 22, 23, 24],
       [25, 26, 27, 28, 29, 30],
       [31, 32, 33, 34, 35, 36]], dtype=uint8)</code></pre>
</div>
</div>
<p>and create a correspinding random mask:</p>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">1</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.random.choice([<span class="va">True</span>, <span class="va">False</span>], elev.shape)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>mask</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>array([[False, False,  True,  True, False, False],
       [False, False, False,  True,  True, False],
       [ True, False, False,  True,  True, False],
       [ True,  True,  True, False,  True,  True],
       [False,  True,  True,  True, False,  True],
       [ True,  True, False, False, False, False]])</code></pre>
</div>
</div>
<p>In the code chunk above, we have created a mask object called <code>mask</code> with values randomly assigned to <code>True</code> and <code>False</code>. Next, we want to keep those values of <code>elev</code> which are <code>False</code> in <code>mask</code> (i.e., they are <em>not</em> masked). In other words, we want to mask <code>elev</code> with <code>mask</code>. The result is stored in a copy named <code>elev1</code>. To be able to store <code>np.nan</code> in the raster, we also need to convert it to float (see <a href="#sec-summarizing-raster-objects"><span class="quarto-unresolved-ref">sec-summarizing-raster-objects</span></a>):</p>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>elev1 <span class="op">=</span> elev.copy()</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>elev1 <span class="op">=</span> elev1.astype(<span class="st">'float64'</span>)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>elev1[mask] <span class="op">=</span> np.nan</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>elev1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="58">
<pre><code>array([[ 1.,  2., nan, nan,  5.,  6.],
       [ 7.,  8.,  9., nan, nan, 12.],
       [nan, 14., 15., nan, nan, 18.],
       [nan, nan, nan, 22., nan, nan],
       [25., nan, nan, nan, 29., nan],
       [nan, nan, 33., 34., 35., 36.]])</code></pre>
</div>
</div>
<p>The result is shown in <a href="#fig-raster-subset">Figure&nbsp;<span class="quarto-unresolved-ref">fig-raster-subset</span></a>.</p>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(elev, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(mask, ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(elev1, ax<span class="op">=</span>axes[<span class="dv">2</span>])</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Mask'</span>)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'Result'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-subset" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-raster-subset-output-1.png" width="632" height="237" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.12: Original raster (left). Raster mask (middle). Output of masking a raster (right).</figcaption>
</figure>
</div>
</div>
</div>
<p>The above approach can be also used to replace some values (e.g., expected to be wrong) with <code>np.nan</code>:</p>
<div class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>elev1 <span class="op">=</span> elev.copy()</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>elev1 <span class="op">=</span> elev1.astype(<span class="st">'float64'</span>)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>elev1[elev1 <span class="op">&lt;</span> <span class="dv">20</span>] <span class="op">=</span> np.nan</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>elev1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="60">
<pre><code>array([[nan, nan, nan, nan, nan, nan],
       [nan, nan, nan, nan, nan, nan],
       [nan, nan, nan, nan, nan, nan],
       [nan, 20., 21., 22., 23., 24.],
       [25., 26., 27., 28., 29., 30.],
       [31., 32., 33., 34., 35., 36.]])</code></pre>
</div>
</div>
<p>These operations are in fact Boolean local operations, since we compare cell-wise two rasters. The next subsection explores these and related operations in more detail.</p>
</section>
<section id="sec-map-algebra" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="sec-map-algebra"><span class="header-section-number">3.4.2</span> Map algebra</h3>
<p>The term ‚Äòmap algebra‚Äô was coined in the late 1970s to describe a ‚Äúset of conventions, capabilities, and techniques‚Äù for the analysis of geographic raster and (although less prominently) vector data (Tomlin 1994). In this context, we define map algebra more narrowly, as operations that modify or summarise raster cell values, with reference to surrounding cells, zones, or statistical functions that apply to every cell.</p>
<p>Map algebra operations tend to be fast, because raster datasets only implicitly store coordinates, hence the old adage ‚Äúraster is faster but vector is corrector‚Äù. The location of cells in raster datasets can be calculated by using its matrix position and the resolution and origin of the dataset (stored in the header). For the processing, however, the geographic position of a cell is barely relevant as long as we make sure that the cell position is still the same after the processing. Additionally, if two or more raster datasets share the same extent, projection and resolution, one could treat them as matrices for the processing.</p>
<p>This is the way that map algebra works with the terra package. First, the headers of the raster datasets are queried and (in cases where map algebra operations work on more than one dataset) checked to ensure the datasets are compatible. Second, map algebra retains the so-called one-to-one locational correspondence, meaning that cells cannot move. This differs from matrix algebra, in which values change position, for example when multiplying or dividing matrices.</p>
<p>Map algebra (or cartographic modeling with raster data) divides raster operations into four subclasses (Tomlin 1990), with each working on one or several grids simultaneously:</p>
<ul>
<li>Local or per-cell operations</li>
<li>Focal or neighborhood operations. Most often the output cell value is the result of a 3 x 3 input cell block</li>
<li>Zonal operations are similar to focal operations, but the surrounding pixel grid on which new values are computed can have irregular sizes and shapes</li>
<li>Global or per-raster operations; that means the output cell derives its value potentially from one or several entire rasters</li>
</ul>
<p>This typology classifies map algebra operations by the number of cells used for each pixel processing step and the type of the output. For the sake of completeness, we should mention that raster operations can also be classified by discipline such as terrain, hydrological analysis, or image classification. The following sections explain how each type of map algebra operations can be used, with reference to worked examples.</p>
</section>
<section id="sec-raster-local-operations" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="sec-raster-local-operations"><span class="header-section-number">3.4.3</span> Local operations</h3>
<p>Local operations comprise all cell-by-cell operations in one or several layers. Raster algebra is a classical use case of local operations - this includes adding or subtracting values from a raster, squaring and multipling rasters. Raster algebra also allows logical operations such as finding all raster cells that are greater than a specific value (5 in our example below). Local operations are applied using the <code>numpy</code> array operations syntax, as demonstrated below:</p>
<p>First, we need to read raster values:</p>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>elev <span class="op">=</span> src_elev.read(<span class="dv">1</span>)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>elev</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="61">
<pre><code>array([[ 1,  2,  3,  4,  5,  6],
       [ 7,  8,  9, 10, 11, 12],
       [13, 14, 15, 16, 17, 18],
       [19, 20, 21, 22, 23, 24],
       [25, 26, 27, 28, 29, 30],
       [31, 32, 33, 34, 35, 36]], dtype=uint8)</code></pre>
</div>
</div>
<p>Now, any element-wise array operation can be applied. For example:</p>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>elev <span class="op">+</span> elev</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="62">
<pre><code>array([[ 2,  4,  6,  8, 10, 12],
       [14, 16, 18, 20, 22, 24],
       [26, 28, 30, 32, 34, 36],
       [38, 40, 42, 44, 46, 48],
       [50, 52, 54, 56, 58, 60],
       [62, 64, 66, 68, 70, 72]], dtype=uint8)</code></pre>
</div>
</div>
<p><a href="#fig-raster-local-operations">Figure&nbsp;<span class="quarto-unresolved-ref">fig-raster-local-operations</span></a> demonstrates a few more examples.</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(elev <span class="op">+</span> elev, ax<span class="op">=</span>axes[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'Oranges'</span>)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(elev1 <span class="op">**</span> <span class="dv">2</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>], cmap<span class="op">=</span><span class="st">'Oranges'</span>)  <span class="co"># using elev here produces int8 overflows</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(np.log(elev), ax<span class="op">=</span>axes[<span class="dv">2</span>], cmap<span class="op">=</span><span class="st">'Oranges'</span>)</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(elev <span class="op">&gt;</span> <span class="dv">5</span>, ax<span class="op">=</span>axes[<span class="dv">3</span>], cmap<span class="op">=</span><span class="st">'Oranges'</span>)</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'elev+elev'</span>)</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'elev ** 2'</span>)</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'np.log(elev)'</span>)</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">3</span>].set_title(<span class="st">'elev &gt; 5'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-local-operations" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-raster-local-operations-output-1.png" width="632" height="191" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.13: Examples of different local operations of the elev raster object: adding two rasters, squaring, applying logarithmic transformation, and performing a logical operation.</figcaption>
</figure>
</div>
</div>
</div>
<p>Another good example of local operations is the classification of intervals of numeric values into groups such as grouping a digital elevation model into low (class 1), middle (class 2) and high elevations (class 3). Here, we assign the raster values in the ranges 0‚Äì12, 12‚Äì24 and 24‚Äì36 are reclassified to take values 1, 2 and 3, respectively.</p>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>recl <span class="op">=</span> elev.copy()</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>recl[(elev <span class="op">&gt;</span> <span class="dv">0</span>)  <span class="op">&amp;</span> (elev <span class="op">&lt;=</span> <span class="dv">12</span>)] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>recl[(elev <span class="op">&gt;</span> <span class="dv">12</span>) <span class="op">&amp;</span> (elev <span class="op">&lt;=</span> <span class="dv">24</span>)] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>recl[(elev <span class="op">&gt;</span> <span class="dv">24</span>) <span class="op">&amp;</span> (elev <span class="op">&lt;=</span> <span class="dv">36</span>)] <span class="op">=</span> <span class="dv">3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The reclassified result is shown in <a href="#fig-raster-reclassify">Figure&nbsp;<span class="quarto-unresolved-ref">fig-raster-reclassify</span></a>.</p>
<div class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(elev, ax<span class="op">=</span>axes[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'Oranges'</span>)</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(recl, ax<span class="op">=</span>axes[<span class="dv">1</span>], cmap<span class="op">=</span><span class="st">'Oranges'</span>)</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Reclassified'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-reclassify" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-raster-reclassify-output-1.png" width="632" height="332" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.14: Reclassifying a continuous raster into three categories.</figcaption>
</figure>
</div>
</div>
</div>
<p>The calculation of the normalized difference vegetation index (NDVI) is a well-known local (pixel-by-pixel) raster operation. It returns a raster with values between -1 and 1; positive values indicate the presence of living plants (mostly &gt; 0.2). NDVI is calculated from red and near-infrared (NIR) bands of remotely sensed imagery, typically from satellite systems such as Landsat or Sentinel. Vegetation absorbs light heavily in the visible light spectrum, and especially in the red channel, while reflecting NIR light, explaining the NVDI formula (<a href="#eq-ndvi">Equation&nbsp;<span class="quarto-unresolved-ref">eq-ndvi</span></a>):</p>
<p><span id="eq-ndvi"><span class="math display">\[NDVI=\frac{NIR-Red} {NIR+Red} \tag{3.1}\]</span></span></p>
<p>Let‚Äôs calculate NDVI for the multispectral satellite file of the Zion National Park.</p>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>multi_rast <span class="op">=</span> src_multi_rast.read()</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>nir <span class="op">=</span> multi_rast[<span class="dv">3</span>,:,:]</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>red <span class="op">=</span> multi_rast[<span class="dv">2</span>,:,:]</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>ndvi <span class="op">=</span> (nir<span class="op">-</span>red)<span class="op">/</span>(nir<span class="op">+</span>red)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Convert values &gt;1 to ‚ÄúNo Data‚Äù:</p>
<div class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>ndvi[ndvi<span class="op">&gt;</span><span class="dv">1</span>] <span class="op">=</span> np.nan</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When plotting an RGB image using the <code>show</code> function, the function assumes that:</p>
<ul>
<li>Values are in the range <code>[0,1]</code> for floats, or <code>[0,255]</code> for integers (otherwise clipped)</li>
<li>The order of bands is RGB</li>
</ul>
<p>To ‚Äúprepare‚Äù the multi-band raster for <code>show</code>, we therefore reverse the order of bands (which is originally BGR+NIR), and divided by the maximum to set the maximum value at <code>1</code>:</p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>multi_rast_rgb <span class="op">=</span> multi_rast[(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>), :, :] <span class="op">/</span> multi_rast.<span class="bu">max</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The result is shown in <a href="#fig-raster-ndvi">Figure&nbsp;<span class="quarto-unresolved-ref">fig-raster-ndvi</span></a>.</p>
<div class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(multi_rast_rgb, ax<span class="op">=</span>axes[<span class="dv">0</span>], cmap<span class="op">=</span><span class="st">'RdYlGn'</span>)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(ndvi, ax<span class="op">=</span>axes[<span class="dv">1</span>], cmap<span class="op">=</span><span class="st">'Greens'</span>)</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'RGB image'</span>)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'NDVI'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-ndvi" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-raster-ndvi-output-1.png" width="621" height="357" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.15: RGB image (left) and NDVI values (right) calculated for the example satellite file of the Zion National Park.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="focal-operations" class="level3" data-number="3.4.4">
<h3 data-number="3.4.4" class="anchored" data-anchor-id="focal-operations"><span class="header-section-number">3.4.4</span> Focal operations</h3>
<p>While local functions operate on one cell, though possibly from multiple layers, focal operations take into account a central (focal) cell and its neighbors. The neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors), but can take on any other (not necessarily rectangular) shape as defined by the user. A focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the the central cell, and moves on to the next central cell (Figure ‚Ä¶). Other names for this operation are spatial filtering and convolution (Burrough, McDonnell, and Lloyd 2015).</p>
<p>In Python, the <code>scipy.ndimage</code> package has a comprehensive collection of <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html#filters">functions</a> to perform filtering of <code>numpy</code> arrays, such as:</p>
<ul>
<li><code>minimum_filter</code></li>
<li><code>maximum_filter</code></li>
<li><code>uniform_filter</code> (i.e., mean filter)</li>
<li><code>median_filter</code> etc.</li>
</ul>
<p>In this group of functions, we define the shape of the moving window with either one of:</p>
<ul>
<li><code>size</code>‚Äîa single number or tuple, implying a filter of those dimensions</li>
<li><code>footprint</code>‚Äîa boolean array, representing both the window shape and the identity of elements being included</li>
</ul>
<p>In addition to specific built-in filters,</p>
<ul>
<li><code>convolve</code> applies the sum function after multiplying by a custom <code>weights</code> array</li>
<li><code>generic_filter</code> makes it possible to pass any custom function, where the user can specify any type of custom window-based calculatio.</li>
</ul>
<p>For example, here we apply the minimum filter with window size of <code>3</code> on <code>elev</code>:</p>
<div class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>elev</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>array([[ 1,  2,  3,  4,  5,  6],
       [ 7,  8,  9, 10, 11, 12],
       [13, 14, 15, 16, 17, 18],
       [19, 20, 21, 22, 23, 24],
       [25, 26, 27, 28, 29, 30],
       [31, 32, 33, 34, 35, 36]], dtype=uint8)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>elev_min <span class="op">=</span> scipy.ndimage.minimum_filter(elev, size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>elev_min</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<pre><code>array([[ 1,  1,  2,  3,  4,  5],
       [ 1,  1,  2,  3,  4,  5],
       [ 7,  7,  8,  9, 10, 11],
       [13, 13, 14, 15, 16, 17],
       [19, 19, 20, 21, 22, 23],
       [25, 25, 26, 27, 28, 29]], dtype=uint8)</code></pre>
</div>
</div>
<p>Special care should be given to the edge pixels. How should they be calculated? <code>scipy.ndimage</code> gives several options through the <code>mode</code> parameter:</p>
<ul>
<li><code>reflect</code> (the default)</li>
<li><code>constant</code></li>
<li><code>nearest</code></li>
<li><code>mirror</code></li>
<li><code>wrap</code></li>
</ul>
<p>Sometimes artificially extending raster edges is considered unsuitable. In other words, we may wish the resulting raster to contain pixel values with ‚Äúcomplete‚Äù windows only, for example to have a uniform sample size or because values in all directions matter (such as in topographic calculations). There is no specific option <em>not</em> to extend edges in <code>scipy.ndimage</code>. However, to get the same effect, the edges of the filtered array can be assigned with <code>nan</code>, in a number of rows and columns according to filter size. For example, when using a filter of <code>size=3</code>, the first ‚Äúlayer‚Äù of pixels may be assigned with <code>nan</code>, reflecting the fact that these pixels have incomplete 3*3 neighborhoods:</p>
<div class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>elev_min <span class="op">=</span> elev_min.astype(<span class="st">'float'</span>)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>elev_min[:, [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]] <span class="op">=</span> np.nan</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>elev_min[[<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>], :] <span class="op">=</span> np.nan</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>elev_min</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="72">
<pre><code>array([[nan, nan, nan, nan, nan, nan],
       [nan,  1.,  2.,  3.,  4., nan],
       [nan,  7.,  8.,  9., 10., nan],
       [nan, 13., 14., 15., 16., nan],
       [nan, 19., 20., 21., 22., nan],
       [nan, nan, nan, nan, nan, nan]])</code></pre>
</div>
</div>
<p>We can quickly check if the output meets our expectations. In our example, the minimum value has to be always the upper left corner of the moving window (remember we have created the input raster by row-wise incrementing the cell values by one starting at the upper left corner).</p>
<p>Focal functions or filters play a dominant role in image processing. Low-pass or smoothing filters use the mean function to remove extremes. In the case of categorical data, we can replace the mean with the mode, which is the most common value. By contrast, high-pass filters accentuate features. The line detection Laplace and Sobel filters might serve as an example here.</p>
<p>Terrain processing, the calculation of topographic characteristics such as slope, aspect and flow directions, relies on focal functions. The <code>TerrainAttribute</code> function from package <code>richdem</code> can be used to calculate common <a href="https://richdem.readthedocs.io/en/latest/python_api.html?highlight=TerrainAttribute#richdem.TerrainAttribute">metrics</a>, specified through the <code>attrib</code> argument, namely:</p>
<ul>
<li><code>slope_riserun</code> Horn (1981) doi: 10.1109/PROC.1981.11918</li>
<li><code>slope_percentage</code> Horn (1981) doi: 10.1109/PROC.1981.11918</li>
<li><code>slope_degrees</code> Horn (1981) doi: 10.1109/PROC.1981.11918</li>
<li><code>slope_radians</code> Horn (1981) doi: 10.1109/PROC.1981.11918</li>
<li><code>aspect</code> Horn (1981) doi: 10.1109/PROC.1981.11918</li>
<li><code>curvature</code> Zevenbergen and Thorne (1987) doi: 10.1002/esp.3290120107</li>
<li><code>planform_curvature</code> Zevenbergen and Thorne (1987) doi: 10.1002/esp.3290120107</li>
<li><code>profile_curvature</code> Zevenbergen and Thorne (1987) doi: 10.1002/esp.3290120107</li>
</ul>
</section>
<section id="zonal-operations" class="level3" data-number="3.4.5">
<h3 data-number="3.4.5" class="anchored" data-anchor-id="zonal-operations"><span class="header-section-number">3.4.5</span> Zonal operations</h3>
<p>Just like focal operations, zonal operations apply an aggregation function to multiple raster cells. However, a second raster, usually with categorical values, defines the zonal filters (or ‚Äòzones‚Äô) in the case of zonal operations, as opposed to a predefined neighborhood window in the case of focal operation presented in the previous section. Consequently, raster cells defining the zonal filter do not necessarily have to be neighbors. Our grain size raster is a good example, as illustrated in the right panel of Figure 3.2: different grain sizes are spread irregularly throughout the raster. Finally, the result of a zonal operation is a summary table grouped by zone which is why this operation is also known as zonal statistics in the GIS world. This is in contrast to focal operations which return a raster object.</p>
<p>To demonstrate, let us get back to the <code>grain</code> and <code>elev</code> rasters (Figure 3.2). To calculate zonal statistics, we use the arrays with raster values. The <code>elev</code> array was already imported earlier:</p>
<div class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>grain <span class="op">=</span> src_grain.read(<span class="dv">1</span>)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>grain</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="73">
<pre><code>array([[1, 0, 1, 2, 2, 2],
       [0, 2, 0, 0, 2, 1],
       [0, 2, 2, 0, 0, 2],
       [0, 0, 1, 1, 1, 1],
       [1, 1, 1, 2, 1, 1],
       [2, 1, 2, 2, 0, 2]], dtype=uint8)</code></pre>
</div>
</div>
<p>Our interntion is to calculate the average (or any other summary function, for that matter) of <em>elevation</em> in each zone defined by <em>grain</em> values. First, we can obtain the unique values defining the zones using <code>np.unique</code>:</p>
<div class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>np.unique(grain)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="74">
<pre><code>array([0, 1, 2], dtype=uint8)</code></pre>
</div>
</div>
<p>Now, we can use <a href="https://stackoverflow.com/questions/14507591/python-dictionary-comprehension">dictionary conprehension</a> to ‚Äúsplit‚Äù the <code>elev</code> array into separate one-dimensional arrays with values per <code>grain</code> group, with keys being the unique <code>grain</code> values:</p>
<div class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> {i: elev[grain <span class="op">==</span> i] <span class="cf">for</span> i <span class="kw">in</span> np.unique(grain)}</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre><code>{0: array([ 2,  7,  9, 10, 13, 16, 17, 19, 20, 35], dtype=uint8),
 1: array([ 1,  3, 12, 21, 22, 23, 24, 25, 26, 27, 29, 30, 32], dtype=uint8),
 2: array([ 4,  5,  6,  8, 11, 14, 15, 18, 28, 31, 33, 34, 36], dtype=uint8)}</code></pre>
</div>
</div>
<p>At this stage, we can expand the dictionary comprehension expression to calculate the mean elevation associated with each grain size class. Instead of placing the elevation values (<code>elev[grain==i]</code>) into the dictionary values, we place their mean (<code>elev[grain==i].mean()</code>):</p>
<div class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> {i: elev[grain <span class="op">==</span> i].mean() <span class="cf">for</span> i <span class="kw">in</span> np.unique(grain)}</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">
<pre><code>{0: 14.8, 1: 21.153846153846153, 2: 18.692307692307693}</code></pre>
</div>
</div>
<p>This returns the statistics for each category, here the mean elevation for each grain size class. For example, the mean elevation in pixels characterized by grain size <code>0</code> is <code>14.8</code>, and so on.</p>
</section>
<section id="sec-global-operations-and-distances" class="level3" data-number="3.4.6">
<h3 data-number="3.4.6" class="anchored" data-anchor-id="sec-global-operations-and-distances"><span class="header-section-number">3.4.6</span> Global operations and distances</h3>
<p>Global operations are a special case of zonal operations with the entire raster dataset representing a single zone. The most common global operations are descriptive statistics for the entire raster dataset such as the minimum or maximum‚Äîwe already discussed those in <a href="#sec-summarizing-raster-objects"><span class="quarto-unresolved-ref">sec-summarizing-raster-objects</span></a>.</p>
<p>Aside from that, global operations are also useful for the computation of distance and weight rasters. In the first case, one can calculate the distance from each cell to specific target cells or vector geometries. For example, one might want to compute the distance to the nearest coast (see example in <a href="#sec-distance-to-nearest-geometry"><span class="quarto-unresolved-ref">sec-distance-to-nearest-geometry</span></a>). We might also want to consider topography, that means, we are not only interested in the pure distance but would like also to avoid the crossing of mountain ranges when going to the coast. To do so, we can weight the distance with elevation so that each additional altitudinal meter ‚Äúprolongs‚Äù the Euclidean distance (this is beyond the scope of the book). Visibility and viewshed computations also belong to the family of global operations (this is also beyond the scope of the book).</p>
</section>
<section id="map-algebra-counterparts-in-vector-processing" class="level3" data-number="3.4.7">
<h3 data-number="3.4.7" class="anchored" data-anchor-id="map-algebra-counterparts-in-vector-processing"><span class="header-section-number">3.4.7</span> Map algebra counterparts in vector processing</h3>
<p>Many map algebra operations have a counterpart in vector processing (Liu and Mason 2009 to add citation‚Ä¶). Computing a distance raster (global operation) while only considering a maximum distance (logical focal operation) is the equivalent to a vector buffer operation (<a href="#sec-buffers"><span class="quarto-unresolved-ref">sec-buffers</span></a>). Reclassifying raster data (either local or zonal function depending on the input) is equivalent to dissolving vector data (Section <a href="#sec-geometry-unions"><span class="quarto-unresolved-ref">sec-geometry-unions</span></a>). Overlaying two rasters (local operation), where one contains ‚ÄúNo Data‚Äù values representing a mask, is similar to vector clipping (Section <a href="#sec-clipping"><span class="quarto-unresolved-ref">sec-clipping</span></a>). Quite similar to spatial clipping is intersecting two layers (Section <a href="#sec-spatial-subsetting"><span class="quarto-unresolved-ref">sec-spatial-subsetting</span></a>). The difference is that these two layers (vector or raster) simply share an overlapping area. However, be careful with the wording. Sometimes the same words have slightly different meanings for raster and vector data models. While aggregating polygon geometries means dissolving boundaries, for raster data geometries it means increasing cell sizes and thereby reducing spatial resolution. Zonal operations dissolve the cells of one raster in accordance with the zones (categories) of another raster dataset using an aggregating function.</p>
</section>
<section id="merging-rasters" class="level3" data-number="3.4.8">
<h3 data-number="3.4.8" class="anchored" data-anchor-id="merging-rasters"><span class="header-section-number">3.4.8</span> Merging rasters</h3>
<p>Suppose we would like to compute the NDVI (see <a href="#sec-raster-local-operations"><span class="quarto-unresolved-ref">sec-raster-local-operations</span></a>), and additionally want to compute terrain attributes from elevation data for observations within a study area. Such computations rely on remotely sensed information. The corresponding imagery is often divided into scenes covering a specific spatial extent (i.e., ‚Äútiles‚Äù), and frequently, a study area covers more than one scene. Then, we would need to merge (also known as ‚Äúmosaic‚Äù) the scenes covered by our study area. In the easiest case, we can just merge these scenes, that is put them side by side. However, the procedure is the same regardless of the number of scenes. In case when all scenes are ‚Äúaligned‚Äù (i.e., share the same origin and resolution), this can be thought of as simply gluing them into one big raster; otherwise, all scenes are resampled (see <a href="#sec-raster-resampling"><span class="quarto-unresolved-ref">sec-raster-resampling</span></a>) to the grid defined by the first scene.</p>
<p>For example, let us merge digital elevation data from two SRTM elevation tiles, for Austria (<code>aut.tif</code>) and Switzerland (<code>ch.tif</code>). Merging can be done using function <code>rasterio.merge.merge</code>, which accepts a <code>list</code> of raster file connections, and returns the new <code>ndarray</code> and a ‚Äútransform‚Äù:</p>
<div class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>src_1 <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'data/aut.tif'</span>)</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>src_2 <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'data/ch.tif'</span>)</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>out_image, out_transform <span class="op">=</span> rasterio.merge.merge([src_1, src_2])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Both inputs and the result are shown in <a href="#fig-raster-merge">Figure&nbsp;<span class="quarto-unresolved-ref">fig-raster-merge</span></a>:</p>
<div class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(src_1, ax<span class="op">=</span>axes[<span class="dv">0</span>][<span class="dv">0</span>])</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(src_2, ax<span class="op">=</span>axes[<span class="dv">0</span>][<span class="dv">1</span>])</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(out_image, transform<span class="op">=</span>out_transform, ax<span class="op">=</span>axes[<span class="dv">1</span>][<span class="dv">0</span>])</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>][<span class="dv">1</span>].axis(<span class="st">'off'</span>)</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>][<span class="dv">0</span>].set_title(<span class="st">'aut.tif'</span>)</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>][<span class="dv">1</span>].set_title(<span class="st">'ch.tif'</span>)</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>][<span class="dv">0</span>].set_title(<span class="st">'Mosaic (aut.tif+ch.tif)'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-merge" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-spatial-operations_files/figure-html/fig-raster-merge-output-1.png" width="641" height="331" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3.16: Raster merging</figcaption>
</figure>
</div>
</div>
</div>
<p>By default (<code>method='first'</code>), areas of overlap retain the value of the <em>first</em> raster. Other possible methods are:</p>
<ul>
<li><code>'last'</code>‚ÄîValue of the last raster</li>
<li><code>'min'</code>‚ÄîMinimum value</li>
<li><code>'max'</code>‚ÄîMaximum value</li>
</ul>
<p>When dealing with non-overlapping tiles, such as <code>aut.tif</code> and <code>ch.tif</code> (above), the <code>method</code> argument has no practical effect. However, it becomes relevant when we want to combine spectral imagery from scenes that were taken on different dates. The above four options for <code>method</code> do not cover the commonly required scenario when we would like to compute the mean value‚Äîfor example to calculate a seasonal average NDVI image from a set of partially overlapping satellite images (such as Landsat). An alternative worflow to <code>rasterio.merge.merge</code>, for calculating a mosaic as well as ‚Äúaveraging‚Äù any overlaps, could be to go through two steps:</p>
<ul>
<li>Resampling all scenes into a common ‚Äúglobal‚Äù grid (<a href="#sec-raster-resampling"><span class="quarto-unresolved-ref">sec-raster-resampling</span></a>), thereby producing a series of ‚Äúmatching‚Äù rasters (with the area surrounding each scene set as ‚ÄúNo Data‚Äù)</li>
<li>Averaging the rasters through raster algebra (<a href="#sec-raster-local-operations"><span class="quarto-unresolved-ref">sec-raster-local-operations</span></a>), as in <code>np.mean(m,axis=0)</code> or <code>np.nanmean(m,axis=0)</code>, where <code>m</code> is the multi-band array, which would return a single-band array of averages</li>
</ul>
</section>
</section>
<section id="exercises" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="exercises"><span class="header-section-number">3.5</span> Exercises</h2>
<ul>
<li>Write a function which accepts and array and an <code>int</code> specifying the number of rows/columns to erase along an array edges. The function needs to return the modified array with <code>np.nan</code> values along its edges.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./03-attribute-operations.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Attribute data operations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./05-geometry-operations.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Geometry operations</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>